'use strict'

/**
 * Expose compositor.
 */

module.exports = compose

/**
 * Compose `middleware` returning
 * a fully valid middleware comprised
 * of all those which are passed.
 *
 * @param {Array} middleware
 * @return {Function}
 * @api public
 */

function compose (middleware) {
  // 参数检查
  if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!')
  for (const fn of middleware) {
    if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!')
  }

  /**
   * @param {Object} context
   * @return {Promise}
   * @api public
   * 假如： middleware.length = 3 初始值的时候
   */

  return function (context, next) {
    // last called middleware #
    //  首先初始化 index 的值
    let index = -1

    // 调用 dispatch 方法， 并定义 index 的值 是 0
    return dispatch(0)

    // i 其实是用来在 this.middleware 中获取中间件的下标

    function dispatch (i) {
      // i = 0 0 > index 所以子继续执行下面的语句
      //  如果一个中间件调用了多次的 next 的话， 会怎么样呢？
      //
      if (i <= index) return Promise.reject(new Error('next() called multiple times'))
      // index = 0
      index = i
      // fn = middleware[0]
      let fn = middleware[i]

      if (i === middleware.length) fn = next
      if (!fn) return Promise.resolve()
      try {
        /**
         * 假设中间件的形式是：
         * function (ctx, next) => {
         *    let date = await asyncFn()
         *    next()
         * }
         *
         * 下面的代码是：
         * fn 作为传入 Promise.resolve 的第一个函数，也就是成功时执行的方法，
         * 也就是说， 我们上面执行 next() 方法就会调用 dispatch(i+1)
         * 既开始这行下一轮， 递归实现， 这下我们也能够理解为什么在中间件中不调用next方法就不可以据需执行的原因了
         *
         *
         *  如果在一个 中间件执行 多次 next 会发生什么呢？
         *
         * funciton (ctx, next) => {
         *   let date = await asyncFn()
         *   下面的 i 是同一个 i, 但是由于已经开始执行下面的中间件了， 所以 index 的值已经大于 i 了， 于是抛出了异常
         *   next();// 即： 执行： dispatch(i + 1)
         *   next();// dispatch(i + 1)
         * }
         *
         */
        // 返回一个 Promise.resolve 包起来主要是为了 兼容 普通函数的情况
        return Promise.resolve(fn(context, function next () {
          return dispatch(i + 1)
        }))
      } catch (err) {
        // 如果其中的一个中间件异常， 则
        return Promise.reject(err)
      }
    }
  }
}
